---
title: "Flammulated Owl Fall Prospecting Analysis"
author: "Scott Yanco"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    code_folding: "show"
    css: style.css 
    toc: true
    toc_float: true
    theme: sandstone
    includes:
      before_body: header.html 
      after_body: footer.html
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = FALSE)
```


#Required Libraries

```{r message=FALSE, warning=FALSE}
# devtools::install_github("cardiomoon/ggiraphExtra")
# devtools::install_github('oswaldosantos/ggsn')
# devtools::install_github("3wen/legendMap")

#data mgmt
library(tidyverse) 
library(reshape2)

#plotting
library(ggplot2)
library(ggmosaic)
library(wesanderson)
library(png)
library(grid)
library(ggiraphExtra)
library(gridExtra)

#inference
library(lme4)
library(AICcmodavg)

#spatial
library(rgdal)
library(sf)
library(ggspatial)
library(ggmap)
library(maptools)
library(broom)
library(tmap)
library(ggsn)
library(legendMap)

#register google maps API key
register_google("AIzaSyAAGi7xr7lrFO3VDYqXN_WO98vlpQSq0bQ")
```

# Initial Data Import, Cleaning, and Management 

## Load and clean dD dataset

```{r}
#read in the raw iso data .csv
owl_deut <- read.csv("data/owl_dD.csv", stringsAsFactors = F)

#replace two cases of missing band #s
#UPDATE THIS - right now this just removes the last two rows...
owl_deut <- owl_deut[1:(nrow(owl_deut)-2),] 

#create new identifier that removes the beginning "o"
id2 <- substring(owl_deut$indentifier, 2)

#create a feather type column that extracts the final letter from the identifier
owl_deut$iso_feath_type <- substr(owl_deut$indentifier,
                                  nchar(owl_deut$indentifier), #start at last
                                  nchar(owl_deut$indentifier)) #stop at last

#write new band column with band number only
owl_deut$band <- substr(id2,1,nchar(id2)-1)

#extract band suffix and add to df
owl_deut$suffix <- as.integer(gsub("(^\\d+\\-)","" ,owl_deut$band))

#extract band prefix and add to df
owl_deut$prefix <- as.integer(gsub("(\\-\\d+$)","" ,owl_deut$band))
```

Next we need to merge the capture and morph datasets into the iso data set.

We'll start by pulling in the fall-only data

```{r}
#load dataset
fall_band <- read.csv("data/fall_band.csv", stringsAsFactors = F)

#merge data frames based on the 3 band columns
owl_comb <- merge(owl_deut, fall_band, by.x = c("band", "suffix", "prefix"),
                  by.y = c("Index.Band", "Suffix", "Prefix"), 
                  all = T)

#update status column for breeding season captures of known residents
owl_comb$ID[is.na(owl_comb$ID)] <- "BR"
```

Next step is to bring in some necessary data from the MEF band dataset for the BR birds.

```{r}
#read in MEF band data as of 2018 field season
mef_band <- read.csv("data/mef_band_2018.csv")

#extract the rows of the MEF data whose band number match those in owl_comb
mef_deut <- mef_band[mef_band$Band.Prefix %in% owl_comb$prefix &
                       mef_band$Band.Suffix %in% owl_comb$suffix,]

#Fill in missing age data from MEF BR birds
#first create data frame of the sex and age values for the 26 MEF BNR birds
missingMEF <- data.frame(
  "Age" = mef_deut$Age[which(mef_deut$Band.Suffix %in% 
                               owl_comb$suffix[is.na(owl_comb$PAge)])],
  "Sex" = mef_deut$Sex[which(mef_deut$Band.Suffix %in% 
                               owl_comb$suffix[is.na(owl_comb$Sex)])],
  "prefix" = mef_deut$Band.Prefix[which(mef_deut$Band.Suffix %in% 
                               owl_comb$suffix[is.na(owl_comb$Sex)])],
  "suffix" = mef_deut$Band.Suffix[which(mef_deut$Band.Suffix %in% 
                               owl_comb$suffix[is.na(owl_comb$Sex)])]
  )

#merge MEf birds into owl_comb  
owl_comb <- merge(owl_comb, missingMEF, by = c("prefix", "suffix"), all.x = T, 
                  no.dups = T)
owl_comb$age <- ifelse(!is.na(owl_comb$PAge), owl_comb$PAge,
                       as.character(owl_comb$Age.y))
owl_comb$sex <- ifelse(!is.na(owl_comb$Sex.x), owl_comb$Sex.x, 
                       as.character(owl_comb$Sex.y))
```

A bit more clening and combining - get combined age and sex columns

```{r}
#make a function to assign a "local" or "unknown" status
makeorigin <-Vectorize(function(x) {
  switch(x, "RA" = "local", "NR" = "local",
                          "RY" = "local", "U" = "unknown", "F" = "unknown",
                          "PF" = "unknown", "BR" = "local")
  }, "x")

#apply function and put results in new column of owl_comb
owl_comb$origin <- as.factor(makeorigin(owl_comb$ID))

#change date format
owl_comb$Date <- as.Date(owl_comb$Date, format = "%d/%m/%Y")

#fix age column
owl_comb$age[owl_comb$age == "2"] <- "AHY"
owl_comb$age[owl_comb$age == "3"] <- "AHY"
owl_comb$age[owl_comb$age == ""] <- NA
owl_comb$age[owl_comb$age == "Ad"] <- "AHY"
owl_comb$age[owl_comb$age == "AD"] <- "AHY"
owl_comb$age[owl_comb$age == "A"] <- "AHY"
owl_comb$age[owl_comb$age == "FL"] <- "HY"
owl_comb$age[owl_comb$age == "L"] <- "HY"
owl_comb$age[owl_comb$age == "Y"] <- "HY"
```

# Compare double measured birds 

This section analyzes birds for which we have two feather isotope values for different feather types.  This helps us validate the use of juvenile  contour feathers in analyses that otherwise include adult remiges.

```{r}
#extract from the complete dataset only those individuals with dD values
deut_data <- owl_comb[!is.na(owl_comb$dD),]

#need to remove duplicated dD data for birds captured twice in a season
deut_data <- distinct(deut_data, band, analysis, .keep_all = T)

#extract all the double measured individuals by keeping only duplicated bands
doubles <- deut_data[duplicated(deut_data$band) | duplicated(deut_data$band, 
                                                             fromLast = T),] 
#sort by band number and then feather type
doubles <- doubles[order(doubles$band, doubles$iso_feath_type),] 

# #remove single case with 2 juv feathers and no primary
# doubles <- filter(doubles, doubles$band != "1833-03340") 

#convert to factors
doubles$band <- as.factor(doubles$band)
```

Now we take the difference in $\delta D$ values between paired measurements from single individuals.

```{r}
difs <- c()
for (i in 1:length(unique(doubles$band))) {
  #first, make sure there are no records using the same feather types
  if(any(doubles$iso_feath_type[doubles$band == 
                                unique(doubles$band)[i]] == "j") &
     any(doubles$iso_feath_type[doubles$band == 
                                unique(doubles$band)[i]] == "p")){
    difs[i] <- doubles$dD[doubles$band == unique(doubles$band)[i] 
                          & doubles$iso_feath_type == "j"] - 
      doubles$dD[doubles$band == unique(doubles$band)[i] &
                   doubles$iso_feath_type == "p"]
  } 
}

difs <- data.frame(dD = na.omit(difs))

```

We now make a plot showing the distribution of differences.

```{r}
difs_plot <- ggplot(data = difs, aes(x = 1, y = dD)) +
  geom_boxplot(width = .2) +
  geom_jitter(position = position_jitter(0.05)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  xlim(c(0.5, 1.5)) +
  ylim(c(-25, 25)) +
  ylab(expression(paste("Difference in ", delta, "D", sep = ""))) +
  theme_classic() +
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(), 
        axis.title.x = element_blank())

difs_plot
```

Inferential test (if we must...), both a paired t-test and an information theoretic approach.

```{r}
#one sample t-test on the pairwise difs (paired t-test)
t.test(x = difs) 

#fit competing linear models
fit.dif.int <- lmer(dD ~ 1 + (1|band), data = doubles, REML = F)
fit.dif.type <- lmer(dD ~ iso_feath_type + (1|band), data = doubles, REML = F)

#make AIC table
aictab(list("intercept" = fit.dif.int, "dD by type" =fit.dif.type))
```

We can clearly see that the t-test showed a high probability of the null hypothesis (no mean pairwise differences between feather types) producing results as or more unusual than ours.  Similarly, the information theoretic approach showed that the most competitive model was intercept only (akin the the null model) and had 78% of the model weighting.  Thee inferences are consistent with our figure and we conclude that the feather type is inconsequential for juvenile birds.

# Isotope analyis for known- and unknown-origin birds

```{r}
#create color palette
pal <- c("#3B9AB2", "#EBCC2A")

#plot histograms with rug plot
deut_hist <- ggplot(data = deut_data) +
  geom_density(aes(x = dD, fill = origin, color = origin), alpha = .35) + 
  scale_fill_manual(values = pal) +
  geom_rug(aes(x = dD, color = origin)) +
  scale_color_manual(values = pal) +
  xlab(expression(paste(delta, "D", sep = ""))) +
  scale_y_continuous(breaks=seq(0,.06,.05)) +
  theme_classic()
deut_hist
```

Again, a couple ways of looking at this inferentially.  First we can do a Kolmogorovâ€“Smirnov  to get a p-value about these being drawn from the same population distribution.  We can also do a two-sample t test to look for differences in means.  Finally, we can again fit a couple linear models and use information theory. 

```{r}
#Kolmolgorv-Smirnov Test
ks.test(x=deut_data$dD[deut_data$origin == "unknown"], 
        y=deut_data$dD[deut_data$origin == "local"])

#Two-sample t-test
t.test(x=deut_data$dD[deut_data$origin == "unknown"], 
        y=deut_data$dD[deut_data$origin == "local"])

#Linear Models and Information Theoretic Selection
fit.int <- lm(dD ~ 1, data = deut_data)
fit.status <- lm(dD ~ origin, data = deut_data)
aictab(list("intercept" = fit.int, "dD by status" = fit.status))
summary(fit.int)
summary(fit.status)
```

Also, some summary stats here.  
```{r}
summary(deut_data$dD[deut_data$origin == "unknown"])
sd(deut_data$dD[deut_data$origin == "unknown"])

summary(deut_data$dD[deut_data$origin == "local"])
sd(deut_data$dD[deut_data$origin == "local"])
```

# Isotope Analysis by Age
We can combine the known- and unknown-origin birds into a single pool and then separate by age to see if differential incorporation of D is related to water use efficiency of young birds.

First we need to remove those values for which age is unknown.

```{r}
deut_data_age <- deut_data[!is.na(deut_data$age),]
```


```{r}
#plot histograms with rug plot
deut_hist_age <- ggplot(data = deut_data_age) +
  geom_density(aes(x = dD, fill = age, color = age), alpha = .35) + 
  scale_fill_manual(values = pal) +
  geom_rug(aes(x = dD, color = age)) +
  scale_color_manual(values = pal) +
  xlab(expression(paste(delta, "D", sep = ""))) +
  scale_y_continuous(breaks=seq(0,.06,.05)) +
  theme_classic()
deut_hist_age
```

We can also vizualize as a boxplot of the means.

```{r}
mean_deut_age <- ggplot(data = deut_data_age) +
  geom_boxplot(aes(x = age, y = dD)) +
  theme_classic()

mean_deut_age
```

Ok, so the young appear to be more depleted than adults - we probably want to now re-do the local- versus unknown-origin analysis comparing adults to adults and young to young...

#Known- versus unknown-origin isotopes controlling for age

We'll make the same histogram as the first time but facet by age.

```{r}
#plot faceted histograms with rug plot
deut_age_origin <- ggplot(data = deut_data_age) +
  geom_density(aes(x = dD, fill = origin, color = origin), alpha = .35) + 
  scale_fill_manual(values = pal) +
  geom_rug(aes(x = dD, color = origin)) +
  scale_color_manual(values = pal) +
  xlab(expression(paste(delta, "D", sep = ""))) +
  scale_y_continuous(breaks=seq(0,.06,.05)) +
  theme_classic() +
  facet_wrap(~age)

deut_age_origin
```

We'll also re-do the information theoretic inference but add interactions for age.

```{r}
#Linear Models and Information Theoretic Selection
fit.int <- lm(dD ~ 1, data = deut_data_age)
fit.age <- lm(dD ~ age, data = deut_data_age)
fit.status <- lm(dD ~ origin, data = deut_data_age)
fit.add <- lm(dD ~ origin + age, data = deut_data_age)
fit.interact <- lm(dD ~ origin*age, data = deut_data_age)

aictab(list("intercept" = fit.int, "age" = fit.age, "origin" = fit.status,
            "origin+age" = fit.add, "origin*age" = fit.interact))

summary(fit.add)
summary(fit.interact)
```

# Fall to Breeding Individuals

Now let's look at our fall birds recaptured as breeders in subsequent years relative to the dD distributions.

```{r}
#vector of F2S band numbers
falltosummer <- c("1783-64429","1833-03191","1783-64490","1783-64452",
                  "1833-03104","1833-03116","1833-03309","1833-03322",
                  "1833-03307","1783-74351","1833-03329","1833-03417")

#get the dD values for F2S birds
recap_deut <- deut_data_age$dD[which(deut_data$band %in% falltosummer)]

#get band numbers of the F2S birds for which we have dD values
recap_bands <- deut_data_age$band[which(deut_data_age$band %in% falltosummer)]
recap_iso_birds <- deut_data_age[which(deut_data_age$band %in% falltosummer),]
recap_iso_birds

#read in owl graphic and transform to rasterGrob object
owl <- readPNG("art/FLOW Line Drawing.png")
g1 <- rasterGrob(owl, interpolate=FALSE)

pal4 <- wes_palette("Zissou1", 4, "discrete")

#plot
deut_cap <- ggplot(data = deut_data_age) +
  geom_density(aes(x = dD, fill = interaction(origin,age), 
                   color = interaction(origin,age)), alpha = .35) + 
  scale_fill_manual(values = pal4) +
  scale_color_manual(values = pal4) +
  geom_vline(xintercept = recap_deut, color = "#3B9AB2", linetype = "dashed") +
  geom_text(aes(x=recap_deut[1]-2, y = .016, 
                label = paste0(recap_bands[1], " (", recap_iso_birds$age[1],
                               ")"), angle = 90)) +
  geom_text(aes(x=recap_deut[2]-2, y = .016, 
                label = paste0(recap_bands[2], " (", recap_iso_birds$age[2],
                               ")"), angle = 90)) +
  annotation_custom(g1, xmin=recap_deut[1]-10, xmax = recap_deut[1],
                    ymin = 0, ymax = .01) +
  annotation_custom(g1, xmin=recap_deut[2]-10, xmax = recap_deut[2], 
                    ymin = 0, ymax = .01) +
  xlab(expression(paste(delta, "D", sep = ""))) +
  scale_y_continuous(breaks=seq(0,.06,.05)) +
  theme_classic()

deut_cap
# ggsave("owlplot.png", dpi = 400)
```

# dD by Time
We can also ask whether we see evidence of migration picking up late by considering whether dD varies by date. We'll first graph it.

```{r}
#dD by julian date
deut_by_date <- ggplot(data = deut_data, aes(x = Julian, y = dD)) +
  geom_point() +
  geom_smooth(method = "lm", color = "black") +
  ylab(expression(paste(delta, "D", sep = ""))) +
  xlab("Julian Date") +
  scale_y_continuous(breaks=c(-85,-65,-45)) +
  scale_x_continuous(breaks=c(244,249,255)) +
  theme_classic()

deut_by_date
```

We can also run the linear model for this.

```{r}
#make dataset without NAa
deut_time <- deut_data[!is.na(deut_data$Julian),] #clean out missing data

#fit models
fit.notime <- lm(dD ~ 1, data = deut_time)
fit.time <- lm(dD ~ Julian, data = deut_time)

#AIC selection
aictab(list("intercept" = fit.notime, "dD by time" = fit.time))
summary(fit.time)
summary(fit.notime)
```

Basically two equally plausible models - interesting that the time covariate model is the best but when we look at the $\beta_1$ estimate it's basically 0 with very high SE, so no real evidence that time explains mean variation in $\delta D$.

We can also separate the dD over time by age groups for age-known birds.

```{r}
#dD by julian date and age
deut_by_date <- ggplot(data = deut_data_age, aes(x = Julian, y = dD, 
                                                 shape = age, color = age)) +
  geom_point() +
  geom_smooth(method = "lm", aes(color = age)) +
  ylab(expression(paste(delta, "D", sep = ""))) +
  xlab("Julian Date") +
  theme_classic()

deut_by_date
```

Let's also re-run the linear models including an interaction with age.
```{r}
#make datset with no missing values for age or Julian 
deut_data_age_time <- deut_data_age[!is.na(deut_data_age$Julian),]

#fit models
fit.notime <- lm(dD ~ 1, data = deut_data_age_time)
fit.time <- lm(dD ~ Julian, data = deut_data_age_time)
fit.timebyage <- lm(dD ~ Julian*age, data = deut_data_age_time)

aictab(list("intercept" = fit.notime, "time" = fit.time, 
            "time*age" = fit.timebyage))

summary(fit.timebyage)
ggPredict(fit.timebyage,se=TRUE) +
  theme_classic()
```


# Passage Rates

First let's load the data in and do any cleaning.

```{r}
#need to get net hours by date to normalize this
caprates <- read.csv("data/nethours.csv")

#convert year to factor
caprates$year <- as.factor(caprates$year)
#caprates <- caprates[-which(caprates$cap_per_hr == max(caprates$cap_per_hr)),]
```

No we can fit a set of linear models to consider any trend in capture rates over time.
```{r}
#Use lm and information theoretics to test hypotheses about rate
#can't do mixed effects because too few data- models don't converge
rate.int <- lm(cap_per_hr ~ 1, data = caprates)
rate.lin <- lm(cap_per_hr ~ julian, data = caprates)
rate.quad <- lm(cap_per_hr ~ poly(julian, 2, raw = T), data = caprates)
aictab(list("intercept" = rate.int, "linear" = rate.lin, 
            "quadratic" = rate.quad))
summary(rate.quad)
summary(rate.int)
summary(rate.lin)

caprates$fit <- predict(rate.quad)
```

Now we're ready to plot the rate over time and we can supply the trendline from our best model (the intercept model).

```{r}
#plot
cap_rate_plot <- ggplot(data = caprates, aes(x=julian, y = cap_per_hr)) +
  geom_point(aes(shape = year), colour="black") +
  # scale_shape_manual(values = c(1:4)) +
  # scale_fill_manual(values = wes_palette("FantasticFox1", 4, "discrete")) +
  geom_smooth(method = "lm", color = "black", 
              formula = y ~ poly(x, 2, raw = T)) +
  ylab(expression("Captures " ~ hr^{-1})) +
  xlab("Julian Date") +
  theme_classic()

cap_rate_plot
ggsave("figures/caprate.png", dpi = 400)
```

# Spatial Analyses

First we need to bring in the relevant data.

```{r}
#read in the recapture data
owl_recap <- read.csv("data/recap_wide.csv")

#make lines for each cap-recap pair
recap_lines <- lapply(X=1:nrow(owl_recap), FUN = function(x) {
  pair <- st_linestring(matrix(c(owl_recap$x_1[x], owl_recap$y_1[x],
                     owl_recap$x_2[x], owl_recap$y_2[x]), byrow = T, 
                     nrow = 2))
  return(pair)
})

#format lines into sfc object
recap_sfc <- st_sfc(recap_lines)

#merge sfc object with original data.frame
mult_recap <- st_sf(owl_recap, geom = recap_sfc, crs = 26913) %>% 
  st_transform("+init=epsg:4326")

#make points for first and second captures
owl_first <- st_as_sf(owl_recap, coords = c("x_1", "y_1"), crs = 26913) %>%   st_transform("+init=epsg:4326")
owl_second <- st_as_sf(owl_recap, coords = c("x_2", "y_2"), 
                       crs = 26913) %>% 
  st_transform("+init=epsg:4326")
#read in the hotel gulch boundary
hotel_bound <- st_read("gis/Hotel_Shp/hotel_boundary.shp", crs = 26913) %>% 
  st_transform("+init=epsg:4326") 

#read in trout creek boundary
trout_bound <- st_read("gis/trout_boundary.shp", crs = 26913) %>% 
  st_transform("+init=epsg:4326")

#read in mizzou boundary
miss_bound <- st_read("gis/missouri_boundary.shp", crs = 26913) %>% 
  st_transform("+init=epsg:4326")

#make hayman boundary
hayman_bound <- st_sfc(st_polygon(x=list(matrix(c(476612, 4335175, 
                         476612, 4328660, 
                         484110, 4328660, 
                         484110, 4335175,
                         476612, 4335175), ncol = 2, byrow = T)))) %>% 
  st_set_crs(26913) %>% 
  st_transform("+init=epsg:4326")

#get google maps base layer
base <- get_googlemap(center = c(lon = -105.1, lat = 39.1), zoom = 11, 
                      maptype ="terrain", color = "bw")
```

Make maps:
```{r }
#make the fall to summer map
f2s_plot <- ggmap(base, darken = c(.3,"#FFFFFF")) +
  xlim(c(-105.1, -105)) +
  ylim(c(39.07, 39.18)) +
  coord_sf() +
  geom_sf(data = hotel_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = miss_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = mult_recap[mult_recap$cap_type == "f2s", ], 
          inherit.aes = FALSE, color = "black") +
  geom_sf(data = owl_first[mult_recap$cap_type == "f2s", ], 
          inherit.aes = FALSE, shape = 15, color = "black") +
  geom_sf(data = owl_second[mult_recap$cap_type == "f2s", ],
          inherit.aes = FALSE, shape = 24, color = "black", fill = "#F0F8FF") +
  ggtitle(expression(Fall %->% Resident)) +
  theme_minimal() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

#make summer to fall map
s2f_plot <- ggmap(base, darken = c(.3,"#FFFFFF")) +
  xlim(c(-105.22, -105.03)) +
  ylim(c(39.07, 39.18)) +
  coord_sf() +
  geom_sf(data = hayman_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = hotel_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = trout_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = miss_bound, inherit.aes = FALSE, fill  = NA, 
          linetype = "twodash", size = 1.25) +
  geom_sf(data = mult_recap[mult_recap$cap_type == "s2f", ], 
          inherit.aes = FALSE, color = "black") +
  geom_sf(data = owl_first[mult_recap$cap_type == "s2f", ], 
          inherit.aes = FALSE, shape = 15, color = "black") +
  geom_sf(data = owl_second[mult_recap$cap_type == "s2f", ],
          inherit.aes = FALSE, shape = 24, color = "black", fill = "#F0F8FF") +
  scale_bar(lon = -105.2, lat = 39.07,
            distance_lon = 2, distance_lat = 0.5, distance_legend = 1,
            dist_unit = "km", orientation = T, arrow_length = 1,
            arrow_distance = 1.25, arrow_north_size = 4) +
  ggtitle(expression(Resident %->% Fall)) +
  theme_minimal() +
  theme(axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank())

grid.arrange(f2s_plot, s2f_plot, widths = c(1.1,2), nrow = 1)
```



# Session Info

```{r}
sessionInfo()
```

